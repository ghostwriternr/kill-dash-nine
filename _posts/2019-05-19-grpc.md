---
layout: post
title: Gee, RPC!
date: 2019-05-19 20:57 +0530
---

![Pancakes!](/images/grpc/pancakes.jpg)

# Introduction

"Woah! I came in here looking for some nerdy info about gRPC - that fancy pants RPC framework everyone is talking about these days. But who is this CUTE monster above?"

Isn't he the cutest? The _cute monster_ is gRPC's mascot, **Pancakes**! Say Hello üê∂

Pancakes is here with a simple introduction to gRPC. This is his first time - so if you find any mistakes, please [raise an issue here](https://github.com/ghostwriternr/kill-dash-nine/issues) and we'll get it fixed stat! **Woof!**

## What is RPC and why is it needed?

### Current scenario

As of today, the vast majority of web APIs on the internet are based on **HTTP + JSON**, with **[REST](https://www.codecademy.com/articles/what-is-rest)** as the architectural principle of how these APIs are designed. HTTP/REST has excellent implementations in every conceivable programming language out there and is extremely popular, but it isn't without it's problems. Some of the **major drawbacks of HTTP/REST** are:
- The client program (the caller) needs to build extra tooling üîß for every new REST API it has to interact with to construct the request headers and payload. Or expect the REST API to come with a client library üìí (in the same language as the client's implentation) so the functionality can be integrated easily.
- No formal machine-readable contract ü§ñ. This makes API discovery impossible and writing client-libraries (for _every_ programming language to be supported) a manual job ü§¢.
- Streaming is almost impossible ‚ùå.
- JSON is a text-based representation, making it extremely bulky/inefficient üê¢ for transmission over network.
- A pure REST-ful paradigm can't model all the capabilities to be supported by the API üëé (example: restarting a machine).

### What are the alternatives?

There are several, but in the current scope, we look at RPC. RPC (Remote Procedure Call) is a request-response protocol.

In Layman terms, RPC allows a program to call, say, a method or an API that could be running anywhere on a remote machine as if it were part of the same program (i.e. using standard language semantics without having to even think about network configurations) and get back a response. [Wikipedia has a more formal definition](https://en.wikipedia.org/wiki/Remote_procedure_call), if interested.


## Welcome gRPC

![gRPC Logo](/images/grpc/grpc-logo.png)

[gRPC](https://grpc.io/) is a modern open source high performance RPC framework that can run in any environment. It can efficiently connect services in and across data centers. gRPC evolved out as the V2 of Google's internal RPC solution - Stubby. gRPC solves all the problems listed above (and more!).

Some of the key features that makes gRPC stand-out are:
- Idiomatic client libraries in 10 languages
- Highly efficient on wire and with a simple service definition framework
- Bi-directional streaming with http/2 based transport
- Pluggable auth, tracing, load balancing and health checking

# Dive into gRPC

## Service definition

gRPC, like many RPC systems, is based around the idea of defining a service, specifying the methods that can be called remotely with their parameters and return types.

By default, gRPC uses protocol buffers as the [Interface Definition Language (IDL)](https://en.wikipedia.org/wiki/Interface_description_language) for describing both the service interface and the structure of the payload messages. It is possible to use other alternatives if desired.

### Protocol Buffers

[Protocol Buffers](https://developers.google.com/protocol-buffers/), or Protobufs, are Google's language-neutral, platform-neutral, extensible mechanism for serializing structured data ‚Äì think XML, but smaller, faster, and simpler.

Protobufs provide type-safety, prevent schema violations, provide simple accessors, backward compatibility and extremely fast serialization/deserialization capabilities.
![Serialization](/images/grpc/serialization.png)
![Deserialization](/images/grpc/deserialization.png)

For protobufs, you define how you want your data to be structured once. Then, protobuf's compiler (`protoc`) can compile them to source code in a variety of languages to easily write and read your structured data.

A very simple service definition with a Unary RPC looks like this:
```protobuf
service HelloService {
  rpc SayHello (HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  string greeting = 1;
}

message HelloResponse {
  string reply = 1;
}
```

Here, the service is called `HelloService` and implements one method called `SayHello`, which takes as parameter message of type `HelloRequest` and returns a `HelloResponse`.

Two things happen at this stage.
1. Since this is a machine-readable contract, the `protoc` compiler can generate a client-library for this API in any of the [35+ supported languages](https://github.com/protocolbuffers/protobuf/blob/master/docs/third_party.md)! For instance, here's the client library for the above API spec in Java:
```js
TODO
```
2. gRPC can also generate server stubs in 10 different languages! For instance, here's the server stub for the above API Spec in Go:
```go
TODO
```

The above generated stub is essentially an interface for the API contract. The server can thus implement the _actual logic_ behind these methods. The client can simply import the interface and call the required methods. gRPC will internally handle making the actual network call! _True magic does exist_.

![Visualisation](/images/grpc/visualisation.png)

## Streaming

gRPC allows 4 types of service method defintions.

### Unary RPCs
The client sends a single request to the server and gets a single response back, just like a normal function call.
```protobuf
rpc SayHello(HelloRequest) returns (HelloResponse){}
```

### Server streaming RPCs
The client sends a request to the server and gets a stream to read a sequence of messages back. The client reads from the returned stream until there are no more messages. gRPC guarantees message ordering within an individual RPC call.
```protobuf
rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse){}
```

### Client streaming RPCs
The client writes a sequence of messages and sends them to the server, again using a provided stream. Once the client has finished writing the messages, it waits for the server to read them and return its response. Again gRPC guarantees message ordering within an individual RPC call.
```protobuf
rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse){}
```

### Bidirectional streaming RPCs
Both sides send a sequence of messages using a read-write stream. The two streams operate independently, so clients and servers can read and write in whatever order they like: for example, the server could wait to receive all the client messages before writing its responses, or it could alternately read a message then write a message, or some other combination of reads and writes. The order of messages in each stream is preserved.
```protobuf
rpc BidiHello(stream HelloRequest) returns (stream HelloResponse){}
```

